import pandas as pd
import numpy as np
import networkx as nx
import networkx as nx
import matplotlib.pyplot as plt
import numpy as np
from scipy.optimize import curve_fit
from networkx.algorithms.community import greedy_modularity_communities, modularity
from collections import Counter

def adj_mx_gnw_goldstandard(filepath: str) -> np.ndarray:
    """
    Convert the edge list provided by GeneNetWeaver as an adjacency matrix.

    Parameter:
    - filepath: filepath of the edge list as .tsv generated by GeneNetWeaver

    Returns:
    - np.ndarray: binary adjacency matrix (1 for interaction and 0 for no interaction)
    """
    df = pd.read_csv(filepath, sep="\t", header=None, names=["source", "target", "interaction"])
    active_edges = df[df["interaction"] == 1]
    G = nx.from_pandas_edgelist(active_edges, source="source", target="target", create_using=nx.DiGraph())
    return nx.adjacency_matrix(G)



def plot_grn_degree(adj_mx, plot_network=False, plot_fit=False):
    """
    Plot the log-log distribution to verify the scale free property of the graph.
    """
    # Create a directed graph from the adjacency matrix
    G = nx.from_numpy_array(adj_mx, create_using=nx.DiGraph())

    degree_sequence = sorted((d for n, d in G.degree()), reverse=True)
    dmax = max(degree_sequence)
    N = G.number_of_nodes()
    
    print('The graph has been loaded as directed graph.')
    
    print('Plotting the graph...')
    fig = plt.figure("Degree of a random graph", figsize=(8, 8))
    axgrid = fig.add_gridspec(5, 4)

    if plot_network:
        ax0 = fig.add_subplot(axgrid[0:3, :])
        Gcc = G.subgraph(sorted(nx.weakly_connected_components(G), key=len, reverse=True)[0])
        pos = nx.kamada_kawai_layout(Gcc)
        nx.draw_networkx_nodes(Gcc, pos, ax=ax0, node_size=20)
        nx.draw_networkx_edges(Gcc, pos, ax=ax0, alpha=0.4)
        ax0.set_title("Gene Regulatory Network")
        ax0.set_axis_off()
    
    print('Computing the degree distribution...')

    # Degree distribution
    degree_counts = np.unique(degree_sequence, return_counts=True)
    degrees = degree_counts[0]
    counts = degree_counts[1]
    probabilities = counts / N

    print('Plotting the scale free verification...')
    ## Log log scale free verification
    ax1 = fig.add_subplot(axgrid[3:, :2])
    ax1.scatter(np.log(degrees), np.log(probabilities), marker="o", color="b")
    ax1.set_title("Scale free verification")
    ax1.set_ylabel("Log of frequency P(k)")
    ax1.set_xlabel("Log of Degree k")

    print('Fitting the power law distribution to the degree distribution...')
    # Function to fit a power law distribution
    def power_law(x, a, b):
        return a * np.power(x, b)

    # Fit the power law distribution to the degree data
    params, _ = curve_fit(power_law, degrees[degrees > 0], probabilities[degrees > 0])

    # Plot the power law fit
    if plot_fit:
        ax1.plot(np.log(degrees[degrees > 0]), np.log(power_law(degrees[degrees > 0], *params)), 'r--', label='Power law fit')
        ax1.legend()

    ## Distribution
    ax2 = fig.add_subplot(axgrid[3:, 2:])
    ax2.bar(degrees, counts)
    ax2.set_title("Degree histogram")
    ax2.set_xlabel("Degree")
    ax2.set_ylabel("# of Nodes")

    fig.tight_layout()
    plt.show()

    print(f'Graph strongly connected: {nx.is_strongly_connected(G)}') # Check if any node can reach every node.
    print(f'Graph weakly connected: {nx.is_weakly_connected(G)}') # Check if the graph is connected regardless of the direction
    
    # Calculate modularity
    try:
        communities = greedy_modularity_communities(G.to_undirected())
        modularity_value = modularity(G.to_undirected(), communities)
        print("Modularity of the graph:", modularity_value)
    except Exception as e:
        print(f"Error in community detection or modularity calculation: {e}")

    # Print the fitted parameters
    print(f"Fitted power law parameters: a = {params[0]:.2f}, b = {params[1]:.2f}")

def graph_properties(adj_mx):
    res = {}
    G = nx.from_numpy_array(adj_mx, create_using=nx.DiGraph())
    degree_sequence = sorted((d for n, d in G.degree()), reverse=True)
    dmax = max(degree_sequence)
    N = G.number_of_nodes()
    degree_counts = np.unique(degree_sequence, return_counts=True)
    degrees = degree_counts[0]
    counts = degree_counts[1]
    probabilities = counts / N

    try:
        communities = greedy_modularity_communities(G.to_undirected())
        modularity_value = modularity(G.to_undirected(), communities)
    except Exception as e:
        print(f"Error in community detection or modularity calculation: {e}")

    res['degrees'] = degrees
    res['probabilities'] = probabilities
    res['strongly_connected'] = nx.is_strongly_connected(G)
    res['weekly_connected'] = nx.is_weakly_connected(G)
    res['modularity_value'] = modularity_value

    return res

def adj_mx_binary(adj_mx):
    binary_adj_mx = adj_mx.copy()
    binary_adj_mx[binary_adj_mx!=0] = 1.
    return binary_adj_mx

def get_all_motifs_count(sub_graph: dict) -> dict:
    motifs = {}
    motifs['Fan-In'] = 1
    motifs['Fan-Out'] = 2
    motifs['Cascade'] = 3
    motifs['Mutual-Out'] = 4
    motifs['Mutual-In'] = 5
    motifs['FFL'] = 6
    motifs['FBL'] = 7
    motifs['Bi-Mutual'] = 8
    motifs['Regulated-Mutual'] = 9
    motifs['Regulating-Mutual'] = 10
    motifs['Mutual-Cascade'] = 11
    motifs['Semi-Clique'] = 12
    motifs['Clique'] = 13

    motif_counts = Counter(sub_graph.values())
    all_motifs_count = {motif: motif_counts.get(motif, 0) for motif in motifs.keys()}
    
    return all_motifs_count

def get_all_motifs_count(sub_graph: dict) -> dict:
    motifs = {}
    motifs['Fan-In'] = 1
    motifs['Fan-Out'] = 2
    motifs['Cascade'] = 3
    motifs['Mutual-Out'] = 4
    motifs['Mutual-In'] = 5
    motifs['FFL'] = 6
    motifs['FBL'] = 7
    motifs['Bi-Mutual'] = 8
    motifs['Regulated-Mutual'] = 9
    motifs['Regulating-Mutual'] = 10
    motifs['Mutual-Cascade'] = 11
    motifs['Semi-Clique'] = 12
    motifs['Clique'] = 13

    motif_counts = Counter(sub_graph.values())
    all_motifs_count = {motif: motif_counts.get(motif, 0) for motif in motifs.keys()}
    
    return all_motifs_count

# Plot the motifs count
def plot_motifs_count(motifs_count):
    motifs = list(motifs_count.keys())
    counts = list(motifs_count.values())

    plt.figure(figsize=(12, 6))
    plt.bar(motifs, np.log(counts), color='skyblue')
    plt.xlabel('Motif')
    plt.ylabel('Count')
    plt.title('Motif Count Distribution')
    plt.xticks(rotation=45)
    plt.tight_layout()
    plt.show()

def plot_motifs_count(motifs_count, log=True):
    motifs = list(motifs_count.keys())
    counts = list(motifs_count.values())
    plt.figure(figsize=(12, 6))
    if log:
        counts_log = [np.log(count) if count > 0 else 0 for count in counts]
        plt.bar(motifs, counts_log, color='skyblue')
    else:
        plt.bar(motifs, counts, color='skyblue')
    plt.xlabel('Motif')
    plt.ylabel('Log Count')
    plt.title('Motif Count Distribution')
    plt.xticks(rotation=45)
    plt.tight_layout()
    plt.show()