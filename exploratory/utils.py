import pandas as pd
import numpy as np
import networkx as nx
import networkx as nx
import matplotlib.pyplot as plt
import numpy as np
from scipy.optimize import curve_fit
from networkx.algorithms.community import greedy_modularity_communities, modularity
from collections import Counter
import random as rd

def adj_mx_gnw_goldstandard(filepath: str) -> np.ndarray:
    """
    Convert the edge list provided by GeneNetWeaver as an adjacency matrix.

    Parameter:
    - filepath: filepath of the edge list as .tsv generated by GeneNetWeaver

    Returns:
    - np.ndarray: binary adjacency matrix (1 for interaction and 0 for no interaction)
    """
    df = pd.read_csv(filepath, sep="\t", header=None, names=["source", "target", "interaction"])
    active_edges = df[df["interaction"] == 1]
    G = nx.from_pandas_edgelist(active_edges, source="source", target="target", create_using=nx.DiGraph())
    return nx.adjacency_matrix(G)



def plot_grn_degree(adj_mx, plot_network=False, plot_fit=False):
    """
    Plot the log-log distribution to verify the scale free property of the graph.
    """
    # Create a directed graph from the adjacency matrix
    G = nx.from_numpy_array(adj_mx, create_using=nx.DiGraph())

    degree_sequence = sorted((d for n, d in G.degree()), reverse=True)
    dmax = max(degree_sequence)
    N = G.number_of_nodes()
    
    print('The graph has been loaded as directed graph.')
    
    print('Plotting the graph...')
    fig = plt.figure("Degree of a random graph", figsize=(8, 8))
    axgrid = fig.add_gridspec(5, 4)

    if plot_network:
        ax0 = fig.add_subplot(axgrid[0:3, :])
        Gcc = G.subgraph(sorted(nx.weakly_connected_components(G), key=len, reverse=True)[0])
        pos = nx.kamada_kawai_layout(Gcc)
        nx.draw_networkx_nodes(Gcc, pos, ax=ax0, node_size=20)
        nx.draw_networkx_edges(Gcc, pos, ax=ax0, alpha=0.4)
        ax0.set_title("Gene Regulatory Network")
        ax0.set_axis_off()
    
    print('Computing the degree distribution...')

    # Degree distribution
    degree_counts = np.unique(degree_sequence, return_counts=True)
    degrees = degree_counts[0]
    counts = degree_counts[1]
    probabilities = counts / N

    print('Plotting the scale free verification...')
    ## Log log scale free verification
    ax1 = fig.add_subplot(axgrid[3:, :2])
    ax1.scatter(np.log(degrees), np.log(probabilities), marker="o", color="b")
    ax1.set_title("Scale free verification")
    ax1.set_ylabel("Log of frequency P(k)")
    ax1.set_xlabel("Log of Degree k")

    print('Fitting the power law distribution to the degree distribution...')
    # Function to fit a power law distribution
    def power_law(x, a, b):
        return a * np.power(x, b)

    # Fit the power law distribution to the degree data
    params, _ = curve_fit(power_law, degrees[degrees > 0], probabilities[degrees > 0])

    # Plot the power law fit
    if plot_fit:
        ax1.plot(np.log(degrees[degrees > 0]), np.log(power_law(degrees[degrees > 0], *params)), 'r--', label='Power law fit')
        ax1.legend()

    ## Distribution
    ax2 = fig.add_subplot(axgrid[3:, 2:])
    ax2.bar(degrees, counts)
    ax2.set_title("Degree histogram")
    ax2.set_xlabel("Degree")
    ax2.set_ylabel("# of Nodes")

    fig.tight_layout()
    plt.show()

    print(f'Graph strongly connected: {nx.is_strongly_connected(G)}') # Check if any node can reach every node.
    print(f'Graph weakly connected: {nx.is_weakly_connected(G)}') # Check if the graph is connected regardless of the direction
    
    # Calculate modularity
    try:
        communities = greedy_modularity_communities(G.to_undirected())
        modularity_value = modularity(G.to_undirected(), communities)
        print("Modularity of the graph:", modularity_value)
    except Exception as e:
        print(f"Error in community detection or modularity calculation: {e}")

    # Print the fitted parameters
    print(f"Fitted power law parameters: a = {params[0]:.2f}, b = {params[1]:.2f}")

def graph_properties(adj_mx):
    res = {}
    G = nx.from_numpy_array(adj_mx, create_using=nx.DiGraph())
    degree_sequence = sorted((d for n, d in G.degree()), reverse=True)
    dmax = max(degree_sequence)
    N = G.number_of_nodes()
    degree_counts = np.unique(degree_sequence, return_counts=True)
    degrees = degree_counts[0]
    counts = degree_counts[1]
    probabilities = counts / N

    try:
        communities = greedy_modularity_communities(G.to_undirected())
        modularity_value = modularity(G.to_undirected(), communities)
    except Exception as e:
        print(f"Error in community detection or modularity calculation: {e}")

    res['degrees'] = degrees
    res['probabilities'] = probabilities
    res['strongly_connected'] = nx.is_strongly_connected(G)
    res['weekly_connected'] = nx.is_weakly_connected(G)
    res['modularity_value'] = modularity_value

    return res

def adj_mx_binary(adj_mx):
    binary_adj_mx = adj_mx.copy()
    binary_adj_mx[binary_adj_mx!=0] = 1.
    return binary_adj_mx

def get_all_motifs_count(sub_graph: dict) -> dict:
    motifs = {}
    motifs['Fan-In'] = 1
    motifs['Fan-Out'] = 2
    motifs['Cascade'] = 3
    motifs['Mutual-Out'] = 4
    motifs['Mutual-In'] = 5
    motifs['FFL'] = 6
    motifs['FBL'] = 7
    motifs['Bi-Mutual'] = 8
    motifs['Regulated-Mutual'] = 9
    motifs['Regulating-Mutual'] = 10
    motifs['Mutual-Cascade'] = 11
    motifs['Semi-Clique'] = 12
    motifs['Clique'] = 13

    motif_counts = Counter(sub_graph.values())
    all_motifs_count = {motif: motif_counts.get(motif, 0) for motif in motifs.keys()}
    
    return all_motifs_count

def plot_motifs_count(motifs_count, log=True):
    motifs = list(motifs_count.keys())
    counts = list(motifs_count.values())
    plt.figure(figsize=(12, 6))
    if log:
        counts_log = [np.log(count) if count > 0 else 0 for count in counts]
        plt.bar(motifs, counts_log, color='skyblue')
    else:
        plt.bar(motifs, counts, color='skyblue')
    plt.xlabel('Motif')
    plt.ylabel('Log Count')
    plt.title('Motif Count Distribution')
    plt.xticks(rotation=45)
    plt.tight_layout()
    plt.show()

# Connect components probabilistically by degree
def connect_components_by_degree(G, hub_bias=1.0):
    """
    Connects disconnected components by adding edges between them.
    Nodes are chosen with probability proportional to (degree ** hub_bias).
    """
    added_edges = 0
    while not nx.is_connected(G):
        components = list(nx.connected_components(G)) # generate connected components
        compA, compB = components[0], components[1] # get the two first components

        # Get the node degress for both components
        degrees_A = np.array([G.degree(n) for n in compA])
        degrees_B = np.array([G.degree(n) for n in compB])

        # Amplify degree for hub preference
        degrees_A = (degrees_A + 1e-3) ** hub_bias
        degrees_B = (degrees_B + 1e-3) ** hub_bias

        # Define the selection probabily of node withing each component
        prob_A = degrees_A / degrees_A.sum()
        prob_B = degrees_B / degrees_B.sum()

        # Select the node for each component
        nodeA = np.random.choice(list(compA), p=prob_A)
        nodeB = np.random.choice(list(compB), p=prob_B)

        # Connect the components with the node selected
        G.add_edge(nodeA, nodeB)
        added_edges += 1
        print(f"Connected node {nodeA} (deg={G.degree(nodeA)}) with {nodeB} (deg={G.degree(nodeB)})")

    print(f"Graph is now connected (added {added_edges} edges).")
    return G

def adjacenteDiMatriceStaredFromGraph(G: nx.Graph,
                                      autoRG: float,
                                      duoRG: float) -> nx.DiGraph:
    """
    Converts an undirected graph into a directed graph
    using a 'star' strategy: the highest-degree node is treated as a hub,
    and edges are oriented outward (with optional bidirectionality and self-loops).
    """
    DiG = nx.DiGraph()
    DiG.add_nodes_from(G)

    # Find the hub node (highest degree)
    degree_dict = dict(G.degree())
    motherNode = max(degree_dict, key=degree_dict.get)
    print(f"Hub node selected for directionality: {motherNode}")

    # Compute node distances from motherNode
    cache = set()
    distance = nx.single_source_shortest_path_length(G, motherNode)

    # Assign direction
    for nodeA in distance:
        for nodeB in G[nodeA]:
            edge = (nodeA, nodeB)
            if edge not in cache: # Prevent going through the edge multiple times
                cache.add(edge)
                cache.add(edge[::-1])
                rdNumber = rd.random()
                if rdNumber < duoRG: # Check if we add a bidirected edge depending on probability duoRG
                    DiG.add_edges_from([(nodeA, nodeB), (nodeB, nodeA)])
                else:
                    if distance[nodeA] <= distance[nodeB]:
                        DiG.add_edge(nodeA, nodeB)
                    else:
                        DiG.add_edge(nodeB, nodeA)
        if rd.random() < autoRG: # Check if we add an autoregulation edge depending on probability autoRG
            DiG.add_edge(nodeA, nodeA)

    return DiG

# Retry loop for LFR benchmark generation
def safe_LFR_benchmark(max_retries=10, **kwargs):
    attempt = 0
    while True:
        try:
            attempt += 1
            G = nx.generators.community.LFR_benchmark_graph(**kwargs)
            print(f"Successfully generated LFR graph on attempt {attempt}.")
            return G, attempt
        except nx.ExceededMaxIterations:
            print(f"Generation failed on attempt {attempt}, retrying...")
            if attempt >= max_retries:
                raise RuntimeError(f"Exceeded max retries ({max_retries}). LFR generation failed.")